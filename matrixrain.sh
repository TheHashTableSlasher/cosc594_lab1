#!/bin/sh

#######################
### Command options ###
#######################

# Paths to each command. These values should work on Hydra machines, but may
# need adjusted on others.
LUA=lua
JGRAPH=~jplank/jgraph
PS2PDF=ps2pdf
CONVERT=convert
FFMPEG=./ffmpeg

# FFmpeg flags. see man ffmpeg(1) for more details, or just don't mess with
# this if you don't know what you're doing.
FFMPEG_flags="-vcodec mjpeg"

###########################
### Matrix rain options ###
###########################

# Raindrop color, as an RGB triple
activecolor="{0.25, 1, 0.25}"

# Raindrop trail color, as an RGB triple
inactivecolor="{0, 0.8, 0}"

# Background color, as an RGB triple
bgcolor="{0, 0, 0}"

# Font size
fontsize=12

# Bernoulli distribution used to spawn new raindrop. Each frame, The script
# will try n times to create a new raindrop with a probability of p. Note that
# this means the rate at which new raindrops are created is dependent on the
# framerate of the video, which can be adjusted below.
spawnn=3
spawnp=0.15

# Speed at which raindrops descend. After the provided amount of time (in
# seconds), a raindrop will descend and add a new character to its trail.
descendspeed=0.04

# Speed with with each character in a raindrop's trail disappears. Each
# character in the trail will fade to the background color and disappear in the
# given amount of time (in seconds).
fadespeed=2

# Probability that a character in a raindrop's trail will spontaneously change
# to a different character in a given frame.
trailinstability=0.004

#####################
### Video options ###
#####################

# Resolution, in dots per inch, of the output video. Keep in mind that the
# graph generated by jgraph is a 3" x 3" square.
dpi=576

# Frames per second of the output video
framerate=30

if [ $# -ne 2 ] ; then
    echo "Usage: $0 <filename> <length>"
    exit 1
fi

# Use bc to do floating-point arithmetic
n=`echo "scale = 20; $2 * $framerate + 0.5" | bc | cut -f 1 -d '.'`
i=0

if [ $n -le 0 ] ; then
    echo "Length must be a nonnegative value"
    exit 1
fi

# Prepare yourself for what is probably the most Turing tar-pit nonsense
# you've seen all day. Don't say I didn't warn you.

# There is absolutely NO nice way to automatically crop jgraph output. I'm not
# even gonna bother with different dimensioned videos; you will have your
# squares and you will like them.
w=$((3 * $dpi))
h=$w
x=`echo "scale = 20; 4.227 * $dpi + 0.5" | bc | cut -f 1 -d '.'`
y=`echo "scale = 20; 3.21  * $dpi + 0.5" | bc | cut -f 1 -d '.'`
crop="`echo $w`x$h+$x+$y"

# We need newlines for strings in jgraph to work, but read can only process by
# newlines in POSIX shell. What do we do? Well, we first use two newlines to
# signify a new jgraph, and then replace all newlines with end-of-record
# characters (could be any character we don't use in the jgraph output). Once
# that's done, we can split by two end-of-record characters with awk. I was
# going to to use sed here, but sed always reads line-by-line and so just loads
# the entire output into memory.
{ $LUA - | tr '\n' '\003' | awk 'BEGIN { RS="\003\003" } { print }' | while IFS="" read line ; do
    if ! [ -z "$line" ] ; then
        # Un-convert the jgraph and render it as a PNG to stdout
        printf "\r%d/%d %s" $i $n `echo -n '/-\|' | cut -c $(($i % 4 + 1))` 1>&2
        echo -n "$line" | tr '\003' '\n' | $JGRAPH -P | $PS2PDF - | $CONVERT -density $dpi - +repage -crop $crop png:-

        i=$(($i + 1))
    fi

    # Note that the heredoc is the input for "lua -", i.e. the actual Lua
    # script, while the output of the loop is piped to FFmpeg, which reads
    # images from stdin and combines them into a video.
done } <<HEREDOC | $FFMPEG -hide_banner -loglevel error -y -f image2pipe -framerate $framerate -i - $FFMPEG_flags "$1"
-- Import some parameters from the shell script
local activecolor = $activecolor
local inactivecolor = $inactivecolor
local bgcolor = $bgcolor
local fontsize = $fontsize
local spawnn = $spawnn
local spawnp = $spawnp
local descendspeed = $descendspeed
local fadespeed = $fadespeed
local trailinstability = $trailinstability

-- Note that these values are approximate
local fontwidth = fontsize * 0.045
local fontheight = fontsize * 0.044
local margin = 10 * 0.125 / 3

local n = $n
local dt = 1 / $framerate

local Raindrop = {charset = {}}
Raindrop.__index = Raindrop

function Raindrop.new(x, y)
    local drop = {
        t = 0,
        x = x,
        y = y,
        next = nil,
        prev = nil,
        string = Raindrop.charset[math.random(1, #Raindrop.charset)],
        font = math.random() < 0.5 and "Times" or "Symbol",
        color = activecolor,
        active = true
    }

    return setmetatable(drop, Raindrop)
end

function Raindrop:step(head, tail)
    if self.active and self.t > descendspeed then
        -- We we go beyond descendspeed, add a new raindrop below this one

        self.active = false

        local y = self.y - fontheight

        if y > 0 then
            raindrop = Raindrop.new(self.x, y)

            if tail[1] then
                tail[1].next = raindrop
            else
                head[1] = raindrop
            end

            raindrop.prev = tail[1]
            tail[1] = raindrop
        end
    end

    if not self.active then
        -- Begin fading if we are part of the trail

        if self.t > descendspeed + fadespeed then
            return nil
        end

        local a = (self.t - descendspeed) / fadespeed

        self.color = {
            inactivecolor[1] * (1 - a) + bgcolor[1] * a,
            inactivecolor[2] * (1 - a) + bgcolor[2] * a,
            inactivecolor[3] * (1 - a) + bgcolor[3] * a
        }

        if math.random() < trailinstability then
            self.string = Raindrop.charset[math.random(1, #Raindrop.charset)]
            self.font = math.random() < 0.5 and "Times" or "Symbol"
        end
    end

    self.t = self.t + dt

    return "newstring hjc vjt font " .. self.font .. " fontsize " .. fontsize ..
          " lcolor " .. self.color[1] .. " " .. self.color[2] .. " " .. self.color[3] ..
          " x " .. self.x .. " y " .. self.y .. " : " .. self.string
end

math.randomseed(os.time())

-- Create a table to pull random characters from
local charset = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"

for i = 1, string.len(charset) do
    Raindrop.charset[#Raindrop.charset + 1] = string.sub(charset, i, i)
end

-- Use tables as head/tail for accessing by reference
local head = {}
local tail = {}

for i = 1, n do
    print("bbox 0 0 3 3") -- Prevents the graph from jumping around the page
    print("newgraph")
    print("xaxis min 0 max 10 nodraw")
    print("yaxis min 0 max 10 nodraw")
    print("newline poly pcfill " .. bgcolor[1] .. " " .. bgcolor[2] .. " " .. bgcolor[3] .. " pts 0 0 0 10 10 10 10 0")

    local raindrop = head[1]

    -- Handle existing raindrops
    while raindrop do
        local jgr = raindrop:step(head, tail)

        if jgr then
            print(jgr)
        else
            -- nil returns means delete the raindrop

            if raindrop.prev then
                raindrop.prev.next = raindrop.next
            else
                head[1] = raindrop.next
            end

            if raindrop.next then
                raindrop.next.prev = raindrop.prev
            else
                tail[1] = raindrop.prev
            end
        end

        raindrop = raindrop.next
    end

    -- Spawn new raindrops based on distribution parameters
    for j = 1, spawnn do
        if math.random() < spawnp then
            raindrop = Raindrop.new(math.random() * 10, 10 + math.random() * fontheight)

            if tail[1] then
                tail[1].next = raindrop
            else
                head[1] = raindrop
            end

            raindrop.prev = tail[1]
            tail[1] = raindrop
        end
    end

    print("") -- Denote new frame with two newlines
end
HEREDOC

printf "\r%d/%d :)\n" $n $n 1>&2
